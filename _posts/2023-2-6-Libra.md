# Libra：A Unified Congestion Control Framework for Diverse Application Preferences and Network Conditions

        随着应用需求和网络多样性的增加，现有的拥塞控制算法（CCA）不能适应这种复杂的现实。以前的经典CCA是为具有固定规则的特定领域设计的，无法适应这种多样性。最近涌现的基于学习的CCA在自适应性和灵活性有巨大的潜力，但是其敛散性、公平性、开销和安全保证上不能令人满意。提出Libra，将传统算法和强化学习算法结合起来，实现了更好的灵活性、适应性和实用性。

## 1、Introduction

        一方面，新的应用程序需要灵活的设置以实现高性能，如云存储或软件下载等应用需要保证吞吐率，而如VR/AR以及云游戏则对延迟敏感。另一方面，网络通信要通过各种不同的网络（如，蜂窝网络，WIFI或者光纤）和不同区域（大陆内或大陆间）。因此，新的CCA需要适应这些条件。

        到目前为止，至少已有15个经典CCA集成到Linux内核中，其基本设计原则是将可能的拥塞信号连接到要采取的固定操作。经典CCA由于其可证明的收敛性和公平性、可预测的行为和可忽略的开销而具有实用性。此外，这些CCA的性能不能超出其领域知识的范围，即专门为有线网络设计的面向吞吐量的CCA（例如，CUBIC）通常在蜂窝网络中表现不佳。

        基于学习的CCA有望提高适应性。同时，Utility函数，可以相应地调整以反映不同的应用程序需求。但最先进的基于学习的CCA尚未实现这些理想愿景。首先，它们的高性能通常是在特定的网络环境下获得的，显示出有限的适应性。它们在有线和蜂窝场景下的性能也有进一步提高的空间（第2节）。第二，离线训练的CCA不能灵活地调整流程中的性能偏好，因为他们的偏好与训练的模型紧密结合。在线学习CCA不关注应用程序偏好。Proteus可以捕获吞吐量需求，但无法调整延迟偏好。此外，基于学习的CCA在收敛性、公平性、开销和安全保证方面的表现令人不满意，这阻碍了大规模部署。

### 总结前面的经验教训，总结CCA应该实现的三个目标：

        （1）适应性，实现在动态网络（包括未知场景）下的高性能

        （2）灵活性，根据应用程序偏好调整性能偏好

        （3）实用性，快速收敛，公平共享链路带宽，提供安全保障，并实现可接受开销。

        为了同时满足这些目标，提出了基于传统和强化学习相结合的Libra。

### Libra和Orca的区别

        Orca是使用基于RL的方案直接调整由CUBIC控制的cwnd。这会导致是Orca的DRL Agent偶尔会输出意外的速率决定，这可能会导致严重的性能下降。

        Libra控制过程：

        （1）探索网络条件

        （2）使用基于utility的框架评估经典CCA和基于学习的CCA的性能

        （3）利用先前的决策并确定下一个控制循环的基本发送速率

        尽管基于utility的框架在高级上类似于PCC，但我们的新颖之处在于重新设计了具有速率控制组件的算法，并对使用我们的组合机制进行了全面探索。通过这些改进，Libra比PCC具有更好的适应性、更快的收敛速度和更低的开销。

        考虑到关于揭示RL公式的影响（即，奖励函数、动作空间和状态空间的设计）的有限文献，我们通过实验总结了关于它的关键观察结果，并相应地优化了基于RL的组件，以提高Libra的性能。然后，我们讨论了经典CCA平滑集成的细节，并为调整参数提供了指导。

        在Linux内核中实现Libra，并在仿真网络和实时互联网中使用最先进的CCA对其进行评估。实验结果表明，Libra可以（1）在不同的网络中始终优于最先进的（例如，吞吐量是Orca的1.2倍）（2）对缓冲区大小、随机损失和参数设置的敏感性低，（3）根据应用需求灵活调整性能偏好，（4）与其他基于学习的CCA相比，CPU利用率降低了92%左右，（5）在协议间和协议内公平性方面保持Jain的公平性指数超过98%，并迅速收敛到公平份额。

## 2、PRELIMINARIES AND MOTIVATION

### Limitations on adaptability:

        现有的经典CCA不能适应各种网络条件。例如，CUBIC和BBR分别由于面向吞吐量的性质和不准确的网络模型，在蜂窝网络中存在bufferbloat和延迟问题。同时，Orca和Proteus与CUBIC相比可以将平均延迟降低60%，在LTE场景中实现比经典CCA低8.4%~13.5%的链路利用率。我们认为，最先进的基于学习的CCA仍有改进的空间（即，在保持低延迟的同时提高链路利用率）。

### Limitations on flexibility:

        经典CCA很难根据不同的应用程序偏好动态调整其行为。一方面，预定义事件和动作之间的硬连线映射使得经典CCA难以调整。另一方面，对于经典CCA，调整应用程序偏好的界面是关闭的。尽管基于学习的方法在某种程度上支持这种接口，但它们只关注特定需求（吞吐量或延迟），不能同时调整多个偏好。

### Limitations on practicality:

        经典CCA始终具有良好的实用性。相比之下，由于实际问题，没有基于学习的CCA被转移到实际生产系统中。

        1）收敛慢，带宽利用率比较低。

        2）性能不稳定，多次实验中带宽利用率不一致，可能的原因，基于学习的组件的决策过程的不确定性。

        3）开销大，基于学习的CCA通常需要复杂的计算，来进行决策。现有的基于纯学习的CCA具有较高的CPU和内存开销（例如，Proteus为88.7%和10.1%，Indigo为18.3%和7.2%）。

        4）基于纯学习的CCA在协议间和协议内公平性方面也表现不佳。
